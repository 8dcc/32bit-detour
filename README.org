#+title: Detour library
#+options: toc:nil
#+startup: showeverything
#+export_file_name: ./doc/README.md
#+author: 8dcc

*Simple linux library for detour hooking in C.*

#+TOC: headlines 2

* Description
This is a linux library, and it supports x64 and x86.

If you want to use this library, simply copy the detour source and headers
to your project, include the header in your source files and compile it with the
rest of your code. Please see [[https://github.com/8dcc/detour-lib/blob/main/src/main.c][src/main.c]] for an example on how to use it.

This library was originally made for [[https://github.com/8dcc/hl-cheat][8dcc/hl-cheat]], and was inspired by [[https://guidedhacking.com/threads/simple-linux-windows-detour-class.10580/][this OOP abomination]].

* Building

#+begin_src console
$ git clone https://github.com/8dcc/detour-lib
$ cd detour-lib
$ make
...
#+end_src

* Usage

First of all, you will need to declare the type of the original function with
the =DECL_DETOUR_TYPE()= macro. You will also need to declare a =detour_data_t=
struct:

#+begin_src c
/* int orig(double a, double b); */
DECL_DETOUR_TYPE(int, orig, double, double);

detour_data_t detour_data;
#+end_src

In this case, the macro will =typedef= a =orig_t= type.

#+begin_quote
*Note:* Make sure these 2 symbols (=orig_t= and =detour_data=) are accessible from your
hook function (i.e. make them global)
#+end_quote

Once you have done that, initialize the =detour_data_t= struct by calling
=detour_init()= with the original and hook pointers, and enable the detour:

#+begin_src c
/* Initialize detour_data struct */
detour_init(&detour_data, orig_ptr, hook_ptr);

/* Detour hook the original function */
detour_add(&detour_data);
#+end_src

If you want to call the original from your hook, you can use the =CALL_ORIGINAL()=
or the =GET_ORIGINAL()= macros (depends on whether you care about the return
value):

#+begin_src c
void hook(double p1, double p2) {
    /* ... */

    /* We care about returned value */
    int result;
    GET_ORIGINAL(detour_data, result, orig_type, p1, p2);

    /* We don't care about the returned value */
    CALL_ORIGINAL(detour_data, orig_type, p1, p2);
}
#+end_src

Once we are done hooking, and we want to restore the original function, we can
call =detour_del()=:

#+begin_src c
detour_del(&detour_data);
#+end_src

If we call =orig()= again, our hook function will not be called.

#+begin_quote
*Note:* The =CALL_ORIGINAL()= macros just remove the patched bytes, call the original
and then patch them again.
#+end_quote

For a full working example, see [[https://github.com/8dcc/detour-lib/blob/main/src/main.c][src/main.c]]. You can also run =make= or =make all-32bit=.
